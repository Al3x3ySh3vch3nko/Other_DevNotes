***
## Структуры данных
***
1 - массив
2 - объект
3 - sets
4 - maps

Какие выбрать.

Данные берутся из 
1) кода, 
2) UI - из действий пользователя (формы, DOM и тп.)
3) Внешних источников (API)

__Если нужен простой лист данных БЕЗ ключей - то массив или сэт__
__Массив:__ 
1-если могут быть повторы данных
2-если нужно будет манипулировать данными
__Сэт:__
1-если нужно работать с уникальными данными
2-когда нужна высокая производительность
3-когда нужно убрать дубликаты из массива

__Если нужны ключи - объекты или map__
__Объект:__
1-более распространен
2-проще писать и получать доступ
Рекомендуется использовать когда 
= нужно включать функции -  значения ключей
= когда данные получены в формате JSON

__Map:__
1-лушая производительность
2-ключами могут быть данные любого типа
3-легко итерировать
4-легко считать размер
Рекомендуется использовать когда 
= нужно просто сопоставить ключи и значения
= когда нужны ключи не только в формате строки

***
#### SET
***
коллекция уникальный данных

сэт не может иметь дублирующих данных

синтаксис 
```
const ordersSet = new Set 
{
    [1,2,3,1,3]
}
```

значением будет объект только с уникальными 3 значениями массива 1, 2 и 3

если передать в сэт строку
`new Set ('АБВ')`
Результатом будет объект с 3 значениями {'А', 'Б, 'В'}

__Параметры сэта:__
=== ordersSet.size - выведет число 3 - количество уникальных значений в нем (как длина массива)
=== ordersSet.has('А') - показывает true или false в зависимости от того, есть ли в сэте значение 'А' или нет (как includes в массиве)
=== ordersSet.add('Д') - добавит в сэт новое значение если оно там отсутствовало
=== ordersSet.delete('Д') - удаляет значение из сэта
=== ordersSet.clear() - очищает сэт

В сэтах нет индекса, так как все данные уникальны.
Чтобы получать данные для использования следует использовать массивы, а не сэты
Возможно использовать циклы в сэтах

Применение:
1) для очистки масcива от повторяющихся данных
ПРИМЕР
```
const staff = ['waiter', 'chief', 'waiter', 'manager']
const staffUnique = [...new Set (staff)] // использование spread оператор для включения в новый массив
```
2) узнать количество уникальных значений
`const staff = ['waiter', 'chief', 'waiter', 'manager']`
`log (new Set (staff).size)`

***
#### MAP
***

Структура данных, которая позволяет сопоставлять значения к ключами
как в объекте - есть ключ, есть значение.
Но в map ключ может быть не только строкой как в объекте.
Создает новый "массив"

__Создание__
` const rest = new Map ();`

__Добавление элементов - ключ и значение.__
При этом использование этих методов не только обновляет переменную rest но и возвращает обновленную map каждый раз.
```
rest.set('name', 'RestName')
rest.set(1, 'RestName2')
rest.set(2, 'RestName3')
```
Это значит, что можно вызывать их по цепочке
```
rest
.set('open', 11)
.set('close', 23)
.set(2, [1,4,3,3,])
.set(true, 'Open')
.set(false, 'Closed')
.set(false, 'Closed')
.set([1,2], 'test')
.set(document.querySelector('h1', 'Heading')
```

другим методом заполнения является передача ключа и значения через массив в котором включены другие массивы
```
const question = new Map(
[
    ['question', 'Thats a question'],
    ['1', 'Answer 1'],
    ['2', 'Answer 2'],
    ['3', 'Answer 3'],
    ['Correct answer', 3],
    [true, 'Answer is correct'],
    [false, 'Answer is not correct']
])
```
Это позволяет конвертировать в объект так как структура похожа когда Используется метод Object.entries
Пример когда объект openingHours становится map hoursMap
```
openingHours: {
    thu: {
      open: 12,
      close: 22,
    },
    fri: {
      open: 11,
      close: 23,
    },
    sat: {
      open: 0, // Open 24 hours
      close: 24,
    },
  },

const hoursMap = new Map (Object.entries(openingHours))
```
__map поддеживает итерации - можно использовать цикл__
```
const question = new Map(
[
    ['question', 'Thats a question'],
    ['1', 'Answer 1'],
    ['2', 'Answer 2'],
    ['3', 'Answer 3'],
    ['Correct answer', 3],
    [true, 'Answer is correct'],
    [false, 'Answer is not correct']
])

for (const [key, value] of question)
{
    if (typeof key === 'number') log(`Answer № ${key} : ${value}`)  
}

const answer = Number(prompt('Your answer')

log(question.get(question.get('correct') === answer)) - дает true или false и в зависимости о этого показывает значение ключа 
 ```
 
__для Конвертации map в массив его добавляют в массив через деструктуризацию__
  `([...question])`
  
__получение значения по ключу__
`rest.get('name')`
`rest.get(true)`

чтобы получить значение по ключу вида [1,2]
требуется создать массив с этим ключом 
`const arr = [1,2]`
ввести его как ключ
`.set(arr, 'test')`
получить значение
`rest.get(arr)`

другой пример использования
```
const time = 21
rest.get(time > rest.get('open') && time < rest.get('close')) // даст в результате булевое значение-ключ, которое в свою очередь даст значение 
```

__поиск есть ли в map ключ__
`rest.has('key')` - дает булевое значение

__удаление значения по ключу__
`rest.delete('key')` 

__размер map__
`rest.size`

__очищение map__
`rest.clear()`

__нахождение значений__
`rest.values()`

Использование:
ПРИМЕР. Сделать MAP и с каждым элементом произвести какую-то манипуляцию

чтобы сделать из массива функцию map и каждый элемент умножить на 2 нужно сделать 2 функции.
1) умножает элемент на 2
2) забирает первую функцию в себя и применяет ее к каждому элементу, возвращает новый массив, умноженный на 2

\\ Исходные данные
`var numbers = [3, 56, 2, 48, 5];`

\\ Функция умножения на 2
```
function double(x)
{
return x*2;
}
```

\\ Переменная, в которую записывается результат map, в которой первая функция
`const newNumbers = numbers.map(double);`

Более короткая запись той же функции
```
const newNumbers = numbers.map(function (x)
{return x*2});
```

Использвование метода map. Создает новый массив где с каждым элементом производится какое-то действие.

ПРИМЕР:
```
const movements = [100, 300, 485, -309, -453, -3444, 4555]
const EURToUSD = 1.1

const movementsUSD = movements.map(function(mov)
{
    return mov * eurToUsd
}
```
\\\ то же самое с arrow function
`const movementsUSD = movements.map (mov => mov * eurToUsd)`

\\\ то же самое с for of
```
const movements = [100, 300, 485, -309, -453, -3444, 4555]
const movementsVsForOf = []
const EURToUSD = 1.1
for (const mov of movements) movementsVsForOf.push(mov * EURToUSD)
```
Метод имеет доступ к 3м аргументам
```
const movementsDescription = movements.map((mov, i, arr) =>
{
   if (mov  > 0)
   {
        return `Movements ${i + 1}: Your deposite ${mov}` 
   }
   else
   {
        return `Movements ${i + 1}: Your withdrew ${Math.abs(mov)}`
   }
   
   \\ или с тернарным оператором
   
   `Movements ${i + 1}: You ${mov > 0 ? 'depostied' : 'withdrew' } ${Math.abs(mov)}`
}
)
```
