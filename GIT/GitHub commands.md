Стадии работы:

1) Инициализация репозитория локально
git init

2) Проверка статуса репозитория
git status

3) Добавление в список отслеживания
git add (название файла)
или 
git add .

Удалить из списка отслеживания конкретный файл
git rm --cached -r (название файла)

4) Коммит
git commit -m "Коммит"  

5) Проверка текущей ветки
git branch

6) Cоздание новой ветки
git branch (название ветки)

7) Удаление ветки 
git branch -D (название ветки)

8) Переключение между ветками
git checkout (название ветки)

9) слияние - находясь на ветке, в которую необходимо добавить изменения 
git merge (название ветки с которой идут изменения)
https://tproger.ru/translations/beginner-git-cheatsheet/

10) создание нового репозитория
создать на github

11) установка соединения локального репозитория и GitHub
git config --global user.name - указывает текущего пользователя 

git config --global user.email - указывает адрес пользователя

при необходимости изменения после этих записей пишется "новое имя" или "новая почта"

git remote add origin (путь к репозиторию)

12) сделать пуш изменений 
git push -u origin (название ветки)

13) взять изменения с репозитория 
git pull

https://tproger.ru/translations/git-tips-and-tricks/

Preparations:

git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"

git config --global core.autocrlf true
git config --global core.safecrlf true

Превратим наш проект в репозиторий git. Для начала просто создайте папку git_site,
затем введите следующие команды: (git_site) = свое название
    
$ mkdir git_site
$ cd git_site
$ git_init 
Где mkdir - команда для создания новых каталогов;
cd - переход в указанную папку; команда cd используется для смены текущего каталога.
   cd .. на уровень выше
   cd \ в корень текущего диска
   d: перейти на диск D
   cd c:\windows перейти в каталог windows

Далее в наш каталог (git_site) можно поместить файлы сайта.
Скопируем файлы сайта в папку git_site. Далее, давайте добавим файлы в репозиторий.

Для этого понадобится выполнить команду:
    
$ git add название файла 

$ git status позволяет отследить состояние репозитория. 
Эта команда позволяет узнать, какие изменения необходимо зарегистрировать git 
(при необходимости, отменить).

$ git log
Выводит историю коммитов

$ git log --pretty=oneline --max-count=3
где,
--pretty=oneline выводит все в одну строчку
--max-count=3 количество показанных коммитов начиная с последнего
--all - все коммиты
--autor="Test User" выводит коммиты только 1 автора

ls = команда, позволяющая проверить какие файлы есть в папке.

Как проверять историю
$ git checkout номер хэша из лога
далее - команда ls чтобы посмотреть файлы на тот момент
далее - gitk чтобы узнать суть изменений

$ git checkout master 
вернуться в основную ветку на тот момент и далее - gitk

Отмена индексации\сброс индексации из буфера

nano имя файла - редактирование файла

git reset HEAD (до внесения изменений или ввести хэш коммита из лога) имя файла
(git reset --hard HEAD) вернет файл в то состояние которое было ранее

далее можно вернуть состояние репозитория до индексации командой: 
git checkout имя файла

Конфликты Merge:

git revert --abort - отмена попытки отката к другой версии 

Для решения конфликта по сути.
Если в файле не видно нововведений, то его надо добавить на индексацию через git add 
далее - git revert --continue
и будет показан статус на каком коммите находимся, далее уже можно 
его редактировать и повторно добавлять в индекс.
далее будет соответствуюзее окно, его можно проверить и идти обратно проверять 
статус git status

 
Ветки:

git branch  = показать все активные ветки

git checkout -b имя ветки = создать новую ветку 

можно делать ветки в ветке

git checkout имя ветки = перейти на ветку

Слияние ветки
перейти в ветку, куда будет производиться слияние
git merge название ветки = слить ветку

Merge конфликт = через nano имя файла зайти и проверить в чем отличие 
в файлах и отредактировать как надо.

далее в git status посмотреть отчет о состоянии и пользоваться подсказками,
сделать abort или добавить отредактированный файл на индексацию.
Выйдет сообщение о решении конфликта, его лучше не трогать, нажать "shift" и ":"
и написать без пробела далее "wq" (записать и выйти).

Для добавления файлов из основной ветки (main к примеру) в рабочую ветку 
следует использовать команду, зайдя в ветку, откуда следует сделать перенос (в main):
git rebase название ветки = это не сохраняет историю пеермещений в логе, это нужно, 
если это просто техническая операция  

Подключение к проекту

в нужной директории ввести 
git clone скопированный адрес директории с гитхаба 
(к примеру, git@github.com:A10-LAB/Bukee_Alexey.git)

Подключение 
git remote add origin адрес с гитхаба

Пушить изменения в GitHub
командой git push

Сначала - git status - проверяем статус
Потом пушим.

Пуш с других веток -заходим на эту ветку
git push origin название ветки
 
git pull --rebase origin master
Делается для того, чтобы скопировать версию с удаленного репозитория
и записать его поверх локальных, не втягиваясь в merge конфликты. 
Rebase - нужен для фиксирования возможных merge конфликтов 

***
Локальные команды
***

$ git init 
Инициализация

$ git status
Проверка добавленных файлов и статуса директории 

$ git add .
Добавление всех файлов в первоначальный "буфер".

$ git add Chapter1.txt 
Добавление конкретного файла

$ git commit -m "1st commit"

$ git log 
Показывает коммиты

$ git diff Chapter3.txt
Показывает сравнение между новой модифицированной версией файла и предыдущей

$ git checkout Chapter3.txt
Откатывает назад изменения модифицированного и добавленного файла к предыдущей версии

$ git rm --cached -r
Убирает последние файлы из добавления

***
Репозиторий
***

Создается на сайте, 
после - копируется адрес.

$ git remote add origin git@github.com:A10-LAB/StoryTest4Git.git 
Изменения инициируются для передачи в репозиторий
 
$ git push -u origin master
Файлы направляются в репозиторий

* GitInore

$ touch .gitignore

* В .gitignore пишутся файлы, которые не будут передаваться в репозиторий
В этом файле # будет означать комментарий.
*.txt - значит, что все файлы с расшрением TXT не будут добавлены в репозиторий.

* На гитхабе в папке gitignore содержится паттерн swift
    
*** 
Клонирование репозитория на локальный диск
***

* На гитхабе скопировать нужный адрес

$ git clone скопированный адрес

***
Ветки
***

* Создание ветки 

$ git branch название

* Проверка веток

$ git branch

* Переход на ветку 

$ git checkout название ветки

* Объединение веток

$ git merge название ветки

В открывшемся редакторе оставить пустым комментарий и для быстрого выхода 
:q!

$ git reflog
# Тут вы увидите всё, что вы делали
# в Git во всех ветках.
# У каждого элемента есть индекс HEAD@{index}.
# Найдите тот, после которого всё сломалось.

$ git reset HEAD@{index}
# Машина времени к вашим услугам.

Я случайно закоммитил что-то в мастер, хотя должен был в новую ветку!
# Эта команда создаст новую ветку из текущего состояния мастера.
$ git branch some-new-branch-name
# А эта — удалит последний коммит из мастер-ветки.
$ git reset HEAD~ --hard
$ git checkout some-new-branch-name
# Теперь ваш коммит полностью независим
Команды не сработают, если вы уже закоммитили в публичную ветку. В таком случае может помочь git reset HEAD@{какое-то-количество-коммитов-назад} вместо HEAD~.

Ну отлично. Я закоммитил не в ту ветку!

# Отменяет последний коммит, но оставляет изменения доступными.
git reset HEAD~ --soft
git stash
# Переключаемся на нужную ветку.
git checkout name-of-the-correct-branch
git stash pop
# Добавьте конкретные файл или не парьтесь и закиньте все сразу.
git add .
git commit -m «Тут будет ваше сообщение»
# Теперь ваши изменения в нужной ветке.

Многие в такой ситуации предлагают использовать cherry-pick, так что можете выбрать, что вам больше по душе.

git checkout name-of-the-correct-branch
# Берём последний коммит из мастера.
git cherry-pick master
# Удаляем его из мастера.
git checkout master
git reset HEAD~ --hard

Мне нужно каким-то образом отменить коммит, который был сделан 5 коммитов назад

# Найдите коммит, который нужно отменить.
git log
# Можно использовать стрелочки, чтобы прокручивать список вверх и вниз.
# Сохраните хэш нужного коммита.
git revert  [тот хэш]
# Git создаст новый коммит, отменяющий выбранный.
# Отредактируйте сообщение коммита или просто сохраните его.

Вам не обязательно откатываться назад и копипастить старые файлы, замещая ими новые. Если вы закоммитили баг, то коммит можно отменить с помощью revert.

Помимо этого, откатить можно не целый коммит, а отдельный файл. Но следуя канону Git’а, это будут уже совсем другие команды…
Мне нужно отменить изменения в файле

# Найдите хэш коммита, до которого нужно откатиться.
git log
# Сохраните хэш нужного коммита.
git checkout [тот хэш] --path/to/file
# Теперь в индексе окажется старая версия файла.
git commit -m «О май гадбл, вы даже не использовали копипаст»

Именно поэтому checkout — лучший инструмент для отката изменений в файлах.


cd ..
sudo rm -r fucking-git-repo-dir
git clone https://some.github.url/fucking-git-repo-dir.git
cd fucking-git-repo-di

Если вам нужно полностью откатиться до исходной версии (т. е. отменить все изменения), то можете попробовать сделать так.

Будьте осторожны, эти команды разрушительны и необратимы.

# Получить последнее состояние origin.
git fetch origin
git checkout master
git reset --hard origin/master
# Удалить неиндексированные файлы и папки.
git clean -d --force
# Повторить checkout/reset/clean для каждой испорченной ветки.



